#!/usr/bin/env python3
"""
Market Chatbot component for the Trading LLM system.
Provides interactive Q&A about market conditions and trading signals.
"""

import logging
from typing import Dict, List, Optional, Any, Tuple

import pandas as pd
import torch
from transformers import PreTrainedModel, PreTrainedTokenizer

from trading_llm.model import TradingLLM
from trading_llm.utils import setup_logging

logger = logging.getLogger(__name__)

class MarketChatbot:
    """
    Interactive chatbot for discussing market conditions and trading decisions.
    
    Maintains conversation history and provides answers about:
    - Current market conditions
    - Recent trading signals
    - Technical analysis explanations
    - Trading strategy insights
    - Historical performance
    """
    
    def __init__(
        self, 
        llm_model: TradingLLM,
        max_history: int = 5,
        system_prompt: Optional[str] = None,
    ):
        """
        Initialize the market chatbot.
        
        Args:
            llm_model: TradingLLM instance for generating responses
            max_history: Maximum number of messages to keep in conversation history
            system_prompt: Custom system prompt to override the default
        """
        self.llm = llm_model
        self.max_history = max_history
        self.conversation_history = []
        
        self.system_prompt = system_prompt or self._default_system_prompt()
        self.market_data = None
        self.trading_signals = None
        self.portfolio_performance = None
        
        setup_logging()
        logger.info("Market Chatbot initialized")
    
    def _default_system_prompt(self) -> str:
        """Default system prompt for the chatbot."""
        return (
            "You are an expert financial advisor and trading assistant with deep knowledge "
            "of technical analysis, market behavior, and trading strategies. "
            "You have access to current market data and trading signals generated by an "
            "advanced reinforcement learning model. "
            "Provide clear, concise, and actionable insights about the market and trades. "
            "When analyzing trading signals, explain the rationale behind them using "
            "technical analysis concepts. "
            "Always be transparent about uncertainty and never make explicit price predictions. "
            "Your answers should be educational, balanced, and focused on explaining market mechanics "
            "rather than making definitive forecasts."
        )
    
    def update_market_data(self, market_data: pd.DataFrame) -> None:
        """
        Update the current market data.
        
        Args:
            market_data: DataFrame containing market data with OHLCV columns and technical indicators
        """
        self.market_data = market_data
        logger.info(f"Updated market data with {len(market_data)} records")
    
    def update_trading_signals(self, signals: Dict[str, Any]) -> None:
        """
        Update the current trading signals from the RL model.
        
        Args:
            signals: Dictionary containing trading signals, positions, and confidence scores
        """
        self.trading_signals = signals
        logger.info("Updated trading signals")
    
    def update_portfolio_performance(self, performance: Dict[str, Any]) -> None:
        """
        Update portfolio performance metrics.
        
        Args:
            performance: Dictionary containing performance metrics like returns, drawdown, etc.
        """
        self.portfolio_performance = performance
        logger.info("Updated portfolio performance metrics")
    
    def _format_conversation_history(self) -> str:
        """Format the conversation history for the prompt."""
        formatted = []
        for msg in self.conversation_history:
            role = msg["role"]
            content = msg["content"]
            formatted.append(f"{role.title()}: {content}")
        return "\n".join(formatted)
    
    def _prepare_market_context(self) -> str:
        """Prepare market context from available data."""
        context_parts = []
        
        if self.market_data is not None:
            recent_data = self.market_data.tail(5)
            market_summary = (
                f"Recent Market Data (last 5 periods):\n"
                f"Close prices: {recent_data['close'].values.tolist()}\n"
                f"Volume: {recent_data['volume'].values.tolist()}\n"
            )
            
            # Add technical indicators if available
            tech_indicators = [col for col in recent_data.columns 
                              if col not in ['open', 'high', 'low', 'close', 'volume', 'timestamp']]
            if tech_indicators:
                market_summary += "Technical Indicators:\n"
                for indicator in tech_indicators[:5]:  # Limit to 5 indicators to keep context manageable
                    market_summary += f"- {indicator}: {recent_data[indicator].iloc[-1]:.4f}\n"
            
            context_parts.append(market_summary)
        
        if self.trading_signals is not None:
            signal_summary = "Current Trading Signals:\n"
            for asset, signal in self.trading_signals.items():
                signal_summary += f"- {asset}: {signal['action']} (confidence: {signal['confidence']:.2f})\n"
            context_parts.append(signal_summary)
        
        if self.portfolio_performance is not None:
            perf_summary = "Portfolio Performance:\n"
            for metric, value in self.portfolio_performance.items():
                perf_summary += f"- {metric}: {value}\n"
            context_parts.append(perf_summary)
        
        return "\n".join(context_parts)
    
    def _build_prompt(self, user_message: str) -> str:
        """
        Build the full prompt with system instruction, context, history, and user message.
        
        Args:
            user_message: The latest user message
            
        Returns:
            Complete prompt string
        """
        market_context = self._prepare_market_context()
        conversation_history = self._format_conversation_history()
        
        prompt = f"""
{self.system_prompt}

Current Information:
{market_context}

Conversation History:
{conversation_history}

User: {user_message}
Assistant:"""
        
        return prompt.strip()
    
    def add_message(self, role: str, content: str) -> None:
        """
        Add a message to the conversation history.
        
        Args:
            role: Either 'user' or 'assistant'
            content: Message content
        """
        if role not in ['user', 'assistant']:
            raise ValueError("Role must be either 'user' or 'assistant'")
        
        self.conversation_history.append({"role": role, "content": content})
        
        # Trim history if needed
        if len(self.conversation_history) > self.max_history * 2:  # *2 because we count pairs
            self.conversation_history = self.conversation_history[-self.max_history*2:]
    
    def chat(self, message: str) -> str:
        """
        Process a user message and generate a response.
        
        Args:
            message: User's message
            
        Returns:
            Assistant's response
        """
        self.add_message("user", message)
        
        # Build the prompt with system instruction, context, history and the new message
        prompt = self._build_prompt(message)
        
        # Generate response
        response = self.llm.generate_text(
            prompt,
            max_new_tokens=512,
            temperature=0.7,
            top_p=0.9,
        )
        
        # Clean response if needed (remove any instances of "Assistant:" prefix)
        response = response.strip()
        if response.startswith("Assistant:"):
            response = response[len("Assistant:"):].strip()
        
        # Add to conversation history
        self.add_message("assistant", response)
        
        return response
    
    def reset_conversation(self) -> None:
        """Reset the conversation history."""
        self.conversation_history = []
        logger.info("Conversation history reset")


def load_market_chatbot(
    model_path: str,
    max_history: int = 5,
    system_prompt: Optional[str] = None,
    device: str = "auto",
) -> MarketChatbot:
    """
    Load a market chatbot with a pre-trained model.
    
    Args:
        model_path: Path to the trained LLM model or Hugging Face model ID
        max_history: Maximum number of message pairs to keep in history
        system_prompt: Custom system prompt
        device: Device to load the model on ('cpu', 'cuda', 'auto')
        
    Returns:
        Initialized MarketChatbot instance
    """
    # Load the TradingLLM model
    llm = TradingLLM.load(model_path, device=device)
    
    # Create and return the chatbot
    return MarketChatbot(
        llm_model=llm,
        max_history=max_history,
        system_prompt=system_prompt,
    ) 